import { BaseEntity } from "./BaseEntity";
import { IAggregateObject, IArgColumn, IIndexOperator, IIdObject, IOrder, IStringOperator, IUniqueValueType, IValueType } from "./types";
export declare class Query<T extends typeof BaseEntity> {
    private readonly _entityType;
    private _onlyDeleted;
    private _offset;
    private _limit;
    private _whereSearches;
    private _whereIndexes;
    private _sortBy;
    private _groupByColumn;
    private _groupByDateFormat;
    constructor(_entityType: T);
    find(idObject: IIdObject<InstanceType<T>>): Promise<InstanceType<T> | undefined>;
    findMany(idObjects: Array<IIdObject<InstanceType<T>>>): Promise<Array<InstanceType<T>>>;
    findUnique(column: IArgColumn<T>, value: IUniqueValueType): Promise<InstanceType<T> | undefined>;
    findUniqueMany(column: IArgColumn<T>, values: IUniqueValueType[]): Promise<Array<InstanceType<T>>>;
    first(): Promise<InstanceType<T> | undefined>;
    get(): Promise<Array<InstanceType<T>>>;
    where(column: IArgColumn<T>, operator: IStringOperator | IIndexOperator, value: IValueType): this;
    onlyDeleted(): Query<T>;
    sortBy(column: IArgColumn<T>, order: IOrder): this;
    offset(value: number): this;
    limit(value: number): this;
    take(value: number): this;
    groupBy(column: IArgColumn<T>): this;
    count(): Promise<number>;
    min(column: IArgColumn<T>): Promise<number | IAggregateObject>;
    max(column: IArgColumn<T>): Promise<number | IAggregateObject>;
    sum(column: IArgColumn<T>): Promise<number | IAggregateObject>;
    avg(column: IArgColumn<T>): Promise<number | IAggregateObject>;
    rank(column: IArgColumn<T>, idObject: IIdObject<InstanceType<T>>, isReverse?: boolean): Promise<number>;
    private _get;
    private _getSimple;
    private _aggregate;
    private _aggregateSimple;
    private _getRedis;
}
